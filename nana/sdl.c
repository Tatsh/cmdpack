////////////////////////////////////////////////////////////////////////////////
//
// Nana graphics viewer
// Copyright (C) 1999,2010 Neill Corlett
//
////////////////////////////////////////////////////////////////////////////////
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
////////////////////////////////////////////////////////////////////////////////

#include "platform.h"

//
// Graphics and input code for SDL
//

#include <SDL.h>

////////////////////////////////////////////////////////////////////////////////

static SDL_Surface *my_screen = NULL;

//
// Screen locking/unlocking
//
static int screen_locked = 0;

static void lock_screen(void) {
    if(!screen_locked) {
        SDL_LockSurface(my_screen);
        screen_locked = 1;
    }
}
static void unlock_screen(void) {
    if(screen_locked) {
        SDL_UnlockSurface(my_screen);
        
        SDL_Flip(my_screen);
        
        screen_locked = 0;
    }
}

////////////////////////////////////////////////////////////////////////////////

const char* platform_name(void) {
#ifdef _WIN32
    return "Win32/SDL";
#else
    return "SDL";
#endif
}

int32_t platform_init(void) {

    if(SDL_Init(SDL_INIT_VIDEO)) {
        fprintf(stderr, "SDL_Init failed: %s\n", SDL_GetError());
        return 1;
    }

    return 0; // ok
}

void platform_quit(void) {
    SDL_Quit();
}

////////////////////////////////////////////////////////////////////////////////
//
// Default VGA palette
//
static SDL_Color vga_palette[256] = {
{0x00,0x00,0x00},{0x00,0x00,0xAA},{0x00,0xAA,0x00},{0x00,0xAA,0xAA},{0xAA,0x00,0x00},{0xAA,0x00,0xAA},{0xAA,0x55,0x00},{0xAA,0xAA,0xAA},
{0x55,0x55,0x55},{0x55,0x55,0xFF},{0x55,0xFF,0x55},{0x55,0xFF,0xFF},{0xFF,0x55,0x55},{0xFF,0x55,0xFF},{0xFF,0xFF,0x55},{0xFF,0xFF,0xFF},
{0x00,0x00,0x00},{0x14,0x14,0x14},{0x20,0x20,0x20},{0x2C,0x2C,0x2C},{0x38,0x38,0x38},{0x44,0x44,0x44},{0x50,0x50,0x50},{0x61,0x61,0x61},
{0x71,0x71,0x71},{0x81,0x81,0x81},{0x91,0x91,0x91},{0xA1,0xA1,0xA1},{0xB6,0xB6,0xB6},{0xCA,0xCA,0xCA},{0xE2,0xE2,0xE2},{0xFF,0xFF,0xFF},
{0x00,0x00,0xFF},{0x40,0x00,0xFF},{0x7D,0x00,0xFF},{0xBE,0x00,0xFF},{0xFF,0x00,0xFF},{0xFF,0x00,0xBE},{0xFF,0x00,0x7D},{0xFF,0x00,0x40},
{0xFF,0x00,0x00},{0xFF,0x40,0x00},{0xFF,0x7D,0x00},{0xFF,0xBE,0x00},{0xFF,0xFF,0x00},{0xBE,0xFF,0x00},{0x7D,0xFF,0x00},{0x40,0xFF,0x00},
{0x00,0xFF,0x00},{0x00,0xFF,0x40},{0x00,0xFF,0x7D},{0x00,0xFF,0xBE},{0x00,0xFF,0xFF},{0x00,0xBE,0xFF},{0x00,0x7D,0xFF},{0x00,0x40,0xFF},
{0x7D,0x7D,0xFF},{0x9D,0x7D,0xFF},{0xBE,0x7D,0xFF},{0xDE,0x7D,0xFF},{0xFF,0x7D,0xFF},{0xFF,0x7D,0xDE},{0xFF,0x7D,0xBE},{0xFF,0x7D,0x9D},
{0xFF,0x7D,0x7D},{0xFF,0x9D,0x7D},{0xFF,0xBE,0x7D},{0xFF,0xDE,0x7D},{0xFF,0xFF,0x7D},{0xDE,0xFF,0x7D},{0xBE,0xFF,0x7D},{0x9D,0xFF,0x7D},
{0x7D,0xFF,0x7D},{0x7D,0xFF,0x9D},{0x7D,0xFF,0xBE},{0x7D,0xFF,0xDE},{0x7D,0xFF,0xFF},{0x7D,0xDE,0xFF},{0x7D,0xBE,0xFF},{0x7D,0x9D,0xFF},
{0xB6,0xB6,0xFF},{0xC6,0xB6,0xFF},{0xDA,0xB6,0xFF},{0xEA,0xB6,0xFF},{0xFF,0xB6,0xFF},{0xFF,0xB6,0xEA},{0xFF,0xB6,0xDA},{0xFF,0xB6,0xC6},
{0xFF,0xB6,0xB6},{0xFF,0xC6,0xB6},{0xFF,0xDA,0xB6},{0xFF,0xEA,0xB6},{0xFF,0xFF,0xB6},{0xEA,0xFF,0xB6},{0xDA,0xFF,0xB6},{0xC6,0xFF,0xB6},
{0xB6,0xFF,0xB6},{0xB6,0xFF,0xC6},{0xB6,0xFF,0xDA},{0xB6,0xFF,0xEA},{0xB6,0xFF,0xFF},{0xB6,0xEA,0xFF},{0xB6,0xDA,0xFF},{0xB6,0xC6,0xFF},
{0x00,0x00,0x71},{0x1C,0x00,0x71},{0x38,0x00,0x71},{0x55,0x00,0x71},{0x71,0x00,0x71},{0x71,0x00,0x55},{0x71,0x00,0x38},{0x71,0x00,0x1C},
{0x71,0x00,0x00},{0x71,0x1C,0x00},{0x71,0x38,0x00},{0x71,0x55,0x00},{0x71,0x71,0x00},{0x55,0x71,0x00},{0x38,0x71,0x00},{0x1C,0x71,0x00},
{0x00,0x71,0x00},{0x00,0x71,0x1C},{0x00,0x71,0x38},{0x00,0x71,0x55},{0x00,0x71,0x71},{0x00,0x55,0x71},{0x00,0x38,0x71},{0x00,0x1C,0x71},
{0x38,0x38,0x71},{0x44,0x38,0x71},{0x55,0x38,0x71},{0x61,0x38,0x71},{0x71,0x38,0x71},{0x71,0x38,0x61},{0x71,0x38,0x55},{0x71,0x38,0x44},
{0x71,0x38,0x38},{0x71,0x44,0x38},{0x71,0x55,0x38},{0x71,0x61,0x38},{0x71,0x71,0x38},{0x61,0x71,0x38},{0x55,0x71,0x38},{0x44,0x71,0x38},
{0x38,0x71,0x38},{0x38,0x71,0x44},{0x38,0x71,0x55},{0x38,0x71,0x61},{0x38,0x71,0x71},{0x38,0x61,0x71},{0x38,0x55,0x71},{0x38,0x44,0x71},
{0x50,0x50,0x71},{0x59,0x50,0x71},{0x61,0x50,0x71},{0x69,0x50,0x71},{0x71,0x50,0x71},{0x71,0x50,0x69},{0x71,0x50,0x61},{0x71,0x50,0x59},
{0x71,0x50,0x50},{0x71,0x59,0x50},{0x71,0x61,0x50},{0x71,0x69,0x50},{0x71,0x71,0x50},{0x69,0x71,0x50},{0x61,0x71,0x50},{0x59,0x71,0x50},
{0x50,0x71,0x50},{0x50,0x71,0x59},{0x50,0x71,0x61},{0x50,0x71,0x69},{0x50,0x71,0x71},{0x50,0x69,0x71},{0x50,0x61,0x71},{0x50,0x59,0x71},
{0x00,0x00,0x40},{0x10,0x00,0x40},{0x20,0x00,0x40},{0x30,0x00,0x40},{0x40,0x00,0x40},{0x40,0x00,0x30},{0x40,0x00,0x20},{0x40,0x00,0x10},
{0x40,0x00,0x00},{0x40,0x10,0x00},{0x40,0x20,0x00},{0x40,0x30,0x00},{0x40,0x40,0x00},{0x30,0x40,0x00},{0x20,0x40,0x00},{0x10,0x40,0x00},
{0x00,0x40,0x00},{0x00,0x40,0x10},{0x00,0x40,0x20},{0x00,0x40,0x30},{0x00,0x40,0x40},{0x00,0x30,0x40},{0x00,0x20,0x40},{0x00,0x10,0x40},
{0x20,0x20,0x40},{0x28,0x20,0x40},{0x30,0x20,0x40},{0x38,0x20,0x40},{0x40,0x20,0x40},{0x40,0x20,0x38},{0x40,0x20,0x30},{0x40,0x20,0x28},
{0x40,0x20,0x20},{0x40,0x28,0x20},{0x40,0x30,0x20},{0x40,0x38,0x20},{0x40,0x40,0x20},{0x38,0x40,0x20},{0x30,0x40,0x20},{0x28,0x40,0x20},
{0x20,0x40,0x20},{0x20,0x40,0x28},{0x20,0x40,0x30},{0x20,0x40,0x38},{0x20,0x40,0x40},{0x20,0x38,0x40},{0x20,0x30,0x40},{0x20,0x28,0x40},
{0x2C,0x2C,0x40},{0x30,0x2C,0x40},{0x34,0x2C,0x40},{0x3C,0x2C,0x40},{0x40,0x2C,0x40},{0x40,0x2C,0x3C},{0x40,0x2C,0x34},{0x40,0x2C,0x30},
{0x40,0x2C,0x2C},{0x40,0x30,0x2C},{0x40,0x34,0x2C},{0x40,0x3C,0x2C},{0x40,0x40,0x2C},{0x3C,0x40,0x2C},{0x34,0x40,0x2C},{0x30,0x40,0x2C},
{0x2C,0x40,0x2C},{0x2C,0x40,0x30},{0x2C,0x40,0x34},{0x2C,0x40,0x3C},{0x2C,0x40,0x40},{0x2C,0x3C,0x40},{0x2C,0x34,0x40},{0x2C,0x30,0x40},
{0x00,0x00,0x00},{0x00,0x00,0x00},{0x00,0x00,0x00},{0x00,0x00,0x00},{0x00,0x00,0x00},{0x00,0x00,0x00},{0x00,0x00,0x00},{0x00,0x00,0x00},
};

////////////////////////////////////////////////////////////////////////////////
//
// Graphics:
//
int graphics_start(const char* name) {
    my_screen = SDL_SetVideoMode(640, 400, 8, SDL_SWSURFACE);
    if(!my_screen) {
        fprintf(stderr, "SDL_SetVideoMode failed: %s\n", SDL_GetError());
        return 1;
    }
    SDL_SetPalette(my_screen, SDL_PHYSPAL, vga_palette, 0, 256);

    {   char* title = malloc(50 + strlen(name));
        if(title) {
            sprintf(title, "%s - Nana", name);
            SDL_WM_SetCaption(title, title);
            free(title);
        }
    }

    SDL_EnableUNICODE(1);

    //
    // TODO: this is annoying. can I make it use the system default rates?
    //
    //SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL);
    SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY / 2, SDL_DEFAULT_REPEAT_INTERVAL);

    return 0;
}

void graphics_end(void) {
    unlock_screen();
}


void graphics_copy_line(int32_t x, int32_t y, const uint8_t* src, int32_t w) {
    lock_screen();

    //
    // Clip
    //
    if(x >= 320) { return; }
    if(y < 0 || y >= 200) { return; }
    if(w <= 0) { return; }
    if(w > 320) { w = 320; }
    if(x < 0) {
        w += x;
        src -= x;
        x = 0;
        if(w <= 0) { return; }
    }
    if((x + w) > 320) {
        w = 320 - x;
    }

    //
    // Copy bytes x 2
    //
    {   uint8_t* dest0 = ((uint8_t*)(my_screen->pixels)) + (2 * y) * my_screen->pitch + (2 * x);
        uint8_t* dest1 = dest0 + my_screen->pitch;

        while(w) {
            dest0[0] =
            dest0[1] =
            dest1[0] =
            dest1[1] = src[0];
            dest0 += 2;
            dest1 += 2;
            src++;
            w--;
        }
    }

    //
    // Keep surface locked so we can do other accesses
    //
}

////////////////////////////////////////////////////////////////////////////////
//
// Input:
//
int32_t input_getkey(void) {

    SDL_Event my_event;

    unlock_screen();

    while(SDL_PollEvent(&my_event)) {
        SDLKey sym;
        SDLMod mod;
        int shift;

        switch(my_event.type) {
        case SDL_QUIT:
            return INPUT_KEY_ESCAPE;

        case SDL_KEYDOWN:
            sym = my_event.key.keysym.sym;
            mod = my_event.key.keysym.mod;
            shift = (mod & (KMOD_LSHIFT | KMOD_RSHIFT)) != 0;

            //fprintf(stderr, "keysym = %d unicode=%d mods=%d\n", my_event.key.keysym.sym, my_event.key.keysym.unicode, my_event.key.keysym.mod);
            switch(sym) {
            case SDLK_ESCAPE  : return INPUT_KEY_ESCAPE;

            case SDLK_UP:
            case SDLK_KP8:
                return shift ? INPUT_KEY_SHIFT_UP : INPUT_KEY_UP;

            case SDLK_DOWN:
            case SDLK_KP2:
                return shift ? INPUT_KEY_SHIFT_DOWN : INPUT_KEY_DOWN;

            case SDLK_LEFT:
            case SDLK_KP4:
                return shift ? INPUT_KEY_SHIFT_LEFT : INPUT_KEY_LEFT;

            case SDLK_RIGHT:
            case SDLK_KP6:
                return shift ? INPUT_KEY_SHIFT_RIGHT : INPUT_KEY_RIGHT;

            case SDLK_PAGEUP:
            case SDLK_KP9:
                return INPUT_KEY_PAGEUP;

            case SDLK_PAGEDOWN:
            case SDLK_KP3:
                return INPUT_KEY_PAGEDOWN;

            case SDLK_HOME:
            case SDLK_KP7:
                return shift ? INPUT_KEY_SHIFT_HOME : INPUT_KEY_HOME;

            case SDLK_END:
            case SDLK_KP1:
                return shift ? INPUT_KEY_SHIFT_END : INPUT_KEY_END;

            }
            if(
                my_event.key.keysym.unicode >= 0x20 &&
                my_event.key.keysym.unicode <= 0x7E
            ) {
                return my_event.key.keysym.unicode;
            }
            break;
        }

    }

    return 0; // nothing?
}

////////////////////////////////////////////////////////////////////////////////
